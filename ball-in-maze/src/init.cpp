#include "header/init.h"

void setupLighting() {
	using namespace Globals;

        // This section deals with lighting for the ball. Only the ball was lit
        // because the maze has static lighting pregenerated by the modeler
	PT(AmbientLight) alight = new AmbientLight("alight");
	alight->set_color(LColor(0.55, 0.55, 0.55, 1));

	PT(DirectionalLight) dlight = new DirectionalLight("dlight");
	dlight->set_direction(LVector3(0, 0, -1));
	dlight->set_color(LColor(0.375, 0.375, 0.375, 1));
	dlight->set_specular_color(LColor(1, 1, 1, 1));

	ball_root.set_light(window->get_render().attach_new_node(alight));
	ball_root.set_light(window->get_render().attach_new_node(dlight));
}

void setupMaterial() {
	using namespace Globals;

        // This section deals with adding a specular highlight to the ball to make
        // it look shiny.  Normally, this is specified in the .egg file.
	PT(Material) material = new Material();
	material->set_specular(LColor(1, 1, 1, 1));
	material->set_shininess(96);
	ball_root.set_material(material, 1);
}

void initPanda(int argc, char* argv[]) {
	using namespace Globals;

	// Set default new window size
	// equivalent to load_prc_file_data("", "win-size 600 600");
	win_size.set_word(0, 600);
	win_size.set_word(1, 600);

	// Open framework (replaces ShowBase).  This will not set up
	// everything like ShowBase, but it does provide convenient functions
	// to do so.
	framework.open_framework();

	//Set the window title and open new window
	framework.set_window_title("Ball in maze - C++ Panda3D Samples");
	window = framework.open_window();
	framework.show_collision_solids(window->get_render());

	// This code puts the standard title and instruction text on screen
	// There is no convenient "OnScreenText" class, although one could
	// be written.  Instead, here are the manual steps:
	TextNode *text_node = new TextNode("title");
	title = NodePath(text_node);
	text_node->set_text("Panda3D: Tutorial - Collision Detection");
	title.reparent_to(window->get_aspect_2d()); // a2d
	text_node->set_align(TextNode::A_right);
	text_node->set_text_color(1, 1, 1, 1);
	title.set_pos(1.0-0.1, 0, -1+0.1); // BottomRight == (1,0,-1)
	title.set_scale(0.08);
	text_node->set_shadow_color(0.0f, 0.0f, 0.0f, 0.5f);
	text_node->set_shadow(0.04, 0.04); // baked into OnscreenText

	text_node = new TextNode("instructions");
	instructions = NodePath(text_node);
	text_node->set_text("Mouse pointer tilts the board");
	instructions.reparent_to(window->get_aspect_2d()); // a2d
	text_node->set_align(TextNode::A_left);
	instructions.set_pos(-1+0.05, 0, 1-0.08); // TopLeft == (-1,0,1)
	text_node->set_text_color(1, 1, 1, 1);
	instructions.set_scale(0.06);
	text_node->set_shadow_color(0.0f, 0.0f, 0.0f, 0.5f);
	text_node->set_shadow(0.04, 0.04); // baked into OnscreenText

	//Keyboard definitions
	window->enable_keyboard();
	// Default key bindings.  In particular, ? displays bindings; ESC quits
	framework.enable_default_keys();
	// Or, as in the Python demo, just Escape quits:
	// framework.define_key("escape", "Escape-key", panda_exit, 0);

	//Camera
	// Mouse was never enabled, so no need to disable.  Just set the camera.
	NodePath camera = window->get_camera_group();
	camera.set_pos_hpr(0, 0, 25, 0, -90, 0);		//Place the camera
}

void setupModels(std::string samplePath) {
	using namespace Globals;

	// Load the maze and place it in the scene
	maze = window->load_model(framework.get_models(), samplePath + "models/maze");
	maze.reparent_to(window->get_render());

        // Most times, you want collisions to be tested against invisible geometry
        // rather than every polygon. This is because testing against every polygon
        // in the scene is usually too slow. You can have simplified or approximate
        // geometry for the solids and still get good results.
        //
        // Sometimes you'll want to create and position your own collision solids in
        // code, but it's often easier to have them built automatically. This can be
        // done by adding special tags into an egg file. Check maze.egg and ball.egg
        // and look for lines starting with <Collide>. The part in brackets tells
        // Panda exactly what to do. Polyset means to use the polygons in that group
        // as solids, while Sphere tells panda to make a collision sphere around them
        // Keep means to keep the polygons in the group as visable geometry (good
        // for the ball, not for the triggers), and descend means to make sure that
        // the settings are applied to any subgroups.
        //
        // Once we have the collision tags in the models, we can get to them using
        // NodePath's find command

	// Find the collision node named wall_colllide
	NodePath walls = maze.find("**/wall_collide");

        // Collision objects are sorted using BitMasks. BitMasks are ordinary numbers
        // with extra methods for working with them as binary bits. Every collision
        // solid has both a from mask and an into mask. Before Panda tests two
        // objects, it checks to make sure that the from and into collision masks
        // have at least one bit in common. That way things that shouldn't interact
        // won't. Normal model nodes have collision masks as well. By default they
        // are set to bit 20. If you want to collide against actual visable polygons,
        // set a from collide mask to include bit 20
        //
        // For this example, we will make everything we want the ball to collide with
        // include bit 0
	DCAST(CollisionNode, walls.node())->set_into_collide_mask(1<<0);
        // CollisionNodes are usually invisible but can be shown. Uncomment the next
        // line to see the collision walls
        //walls.show();

        // We will now find the triggers for the holes and set their masks to 0 as
        // well. We also set their names to make them easier to identify during
        // collisions
	for (size_t i = 0; i < 6; i++) {
		NodePath trigger = maze.find("**/hole_collide" + std::to_string(i));
		trigger.node()->set_into_collide_mask(1<<0);
		trigger.node()->set_name("loseTrigger");
		lose_triggers.push_back(trigger);
		// Uncomment this line to see the triggers
		//trigger.show();
	}

        // Ground_collide is a single polygon on the same plane as the ground in the
        // maze. We will use a ray to collide with it so that we will know exactly
        // what height to put the ball at every frame. Since this is not something
        // that we want the ball itself to collide with, it has a different
        // bitmask.
	NodePath maze_ground = maze.find("**/ground_collide");
	DCAST(CollisionNode, maze_ground.node())->set_into_collide_mask(1<<1);

        // Load the ball and attach it to the scene
        // It is on a root dummy node so that we can rotate the ball itself without
        // rotating the ray that will be attached to it
	ball_root = window->get_render().attach_new_node("ballRoot");
	ball = window->load_model(framework.get_models(), samplePath + "models/ball");
	ball.reparent_to(ball_root);

        // Find the collison sphere for the ball which was created in the egg file
        // Notice that it has a from collision mask of bit 0, and an into collison
        // mask of no bits. This means that the ball can only cause collisions, not
        // be collided into
	NodePath ball_sphere = ball.find("**/ball");
	DCAST(CollisionNode, ball_sphere.node())->set_from_collide_mask(1<<0);
	DCAST(CollisionNode, ball_sphere.node())->set_into_collide_mask(0);

        // Now we create a ray to start above the ball and cast down. This is to
        // Determine the height the ball should be at and the angle the floor is
        // tilting. We could have used the sphere around the ball itself, but it
        // would not be as reliable
	PT(CollisionRay) ball_ground_ray = new CollisionRay();	//Create the ray
	ball_ground_ray->set_origin(0, 0, 10);			//Set its origin
	ball_ground_ray->set_direction(0, 0, -1);		//And its direction
        // Collision solids go in CollisionNode
        // Create and name the node
	PT(CollisionNode) ball_ground_col = new CollisionNode("groundRay");
	ball_ground_col->add_solid(ball_ground_ray);	//Add the ray
	ball_ground_col->set_from_collide_mask(1<<1);	//Set its bitmasks
	ball_ground_col->set_into_collide_mask(0);
        // Attach the node to the ballRoot so that the ray is relative to the ball
        // (it will always be 10 feet over the ball and point down)
	NodePath ball_ground_col_NP = ball_root.attach_new_node(ball_ground_col);
        // Uncomment this line to see the ray
        //ball_ground_col_NP.show();

        // Finally, we create a CollisionTraverser. CollisionTraversers are what
        // do the job of walking the scene graph and calculating collisions.
        // For a traverser to actually do collisions, you need to call
        // traverser.traverse() on a part of the scene.  For this example, this
	// is done by a task called roll_task, which does this for the entire
	// scene once a frame.  This automatically/only uses collision_traverser,
	// defined in Globals
	//CollisionTraverser collistion_traverser;

        // Collision traversers tell collision handlers about collisions, and then
        // the handler decides what to do with the information. We are using a
        // CollisionHandlerQueue, which simply creates a list of all of the
        // collisions in a given pass. There are more sophisticated handlers like
        // one that sends events and another that tries to keep collided objects
        // apart, but the results are often better with a simple queue
	// This is once again in Globals:
	//PT(CollistionHandlerQUeue) collistion_handler = new CollistionHandlerQueue();
	
        // Now we add the collision nodes that can create a collision to the
        // traverser. The traverser will compare these to all others nodes in the
        // scene. There is a limit of 32 CollisionNodes per traverser
        // We add the collider, and the handler to use as a pair
	collision_traverser.add_collider(ball_sphere, collision_handler);
	collision_traverser.add_collider(ball_ground_col_NP, collision_handler);

        // Collision traversers have a built in tool to help visualize collisions.
        // Uncomment the next line to see it.
        //collision_traverser.show_collisions(window->get_render());
}
